<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
<!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

<title>Android面试题</title>
<meta name="author" content="wenmingvs">

<meta name="keywords" content="undefined">

<meta name="description " content="人生我爱">

<link rel="icon" href="http://tp2.sinaimg.cn/1763492177/180/5669531068/1">

<link rel="stylesheet" href="/css/style.css" type="text/css">
  </head>
  <body>
    <aside id="sidebar">
  <nav id="tags">
    <a href="http://www.zhihu.com/people/hong-lou" id="avatar" style="background-image:url(http://tp2.sinaimg.cn/1763492177/180/5669531068/1)"></a>
    <ul id="tags__ul">
      <li id="pl__all" class="tags__li tags-btn active">所有文章</li>
      
      <li id="Android" class="tags__li tags-btn">Android</li>
      
      <li id="人生感悟" class="tags__li tags-btn">人生感悟</li>
      
      <li id="Java" class="tags__li tags-btn">Java</li>
      
      <li id="Git" class="tags__li tags-btn">Git</li>
      
    </ul>
    <div id="tags__bottom">
      <a href="http://github.com/wenmingvs" rel="nofollow" id="icon-github" target="_blank" class="tags-btn fontello"></a>
      <a href="http://weibo.com/wenmingvs" rel="nofollow" id="icon-qq" target="_blank" class="tags-btn fontello"></a>
    </div>
  </nav> <!-- end #tags -->
  <div id="posts-list">
    <form action="https://www.baidu.com/s?wd=site:shuoit.net" id="search-form" target="_blank">
      <a href="/" id="mobile-avatar" style="background-image:url(http://tp2.sinaimg.cn/1763492177/180/5669531068/1)"></a>
      <input id="search-input" type="text" placeholder="百度搜索" />
    </form>
    <nav id="pl__container">
      
            
                <a class="Android pl__all" href="/2015/12/07/Android面试题/" title="Android面试题">
                  
                  <span class="pl__circle"></span><span class="pl__title">Android面试题</span><span class="pl__date">2015-12-07</span>
                </a>
            
      
            
                <a class="人生感悟 pl__all" href="/2015/12/07/人生感悟/" title="2016 校招， Android 开发，一个本科应届的坎坷求职之路">
                  
                  <span class="pl__circle"></span><span class="pl__title">2016 校招， Android 开发，...</span><span class="pl__date">2015-12-07</span>
                </a>
            
      
            
                <a class="Java pl__all" href="/2015/12/07/Java面试题/" title="Java面试题">
                  
                  <span class="pl__circle"></span><span class="pl__title">Java面试题</span><span class="pl__date">2015-12-07</span>
                </a>
            
      
            
                <a class="Git pl__all" href="/2015/12/20/Git笔记/" title="Git笔记">
                  
                  <span class="pl__circle"></span><span class="pl__title">Git笔记</span><span class="pl__date">2015-12-20</span>
                </a>
            
      
    </nav>
  </div> <!-- end #posts-list -->
</aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="2015-12-07">Android面试题</h1>
  <h1 id="Android面试题">Android面试题</h1><p>[toc]</p>
<hr>
<h2 id="1-_Activity_系列问题">1. Activity 系列问题</h2><h3 id="1-1_绘制Activity生命周期流程图">1.1 绘制Activity生命周期流程图</h3><p><img src="http://img.my.csdn.net/uploads/201303/08/1362732913_3457.jpg" alt="enter image description here"></p>
<h3 id="1-2_介绍下不同场景下Activity生命周期的变化过程">1.2 介绍下不同场景下Activity生命周期的变化过程</h3><ul>
<li><strong>启动Activity</strong>：<br>onCreate()—&gt;onStart()—&gt;onResume()，Activity进入运行状态。</li>
<li><strong>Activity退居后台</strong>：<br>当前Activity转到新的Activity界面或按Home键回到主屏：<br>onPause()—&gt;onStop()，进入停滞状态。</li>
<li><strong>Activity返回前台</strong>：<br>onRestart()—&gt;onStart()—&gt;onResume()，再次回到运行状态。</li>
<li><strong>Activity退居后台，且系统内存不足</strong>，<br>系统会杀死这个后台状态的Activity，若再次回到这个Activity,则会走onCreate()–&gt;onStart()—&gt;onResume()</li>
<li><strong>锁定屏与解锁屏幕</strong><br>只会调用onPause()，而不会调用onStop方法，开屏后则调用onResume()</li>
</ul>
<h3 id="1-3_内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？">1.3 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？</h3><p>Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法，它们并不一定会被触发。当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。除非该activity是被用户主动销毁的，通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。</p>
<h3 id="1-4_onSaveInstanceState()被执行的场景有哪些：">1.4 onSaveInstanceState()被执行的场景有哪些：</h3><p>系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统都会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</p>
<ol>
<li>当用户按下HOME键时</li>
<li>长按HOME键，选择运行其他的程序时</li>
<li>锁屏时</li>
<li>从activity A中启动一个新的activity时</li>
<li>屏幕方向切换时</li>
</ol>
<h3 id="1-5_介绍Activity的几中启动模式，并简单说说自己的理解或者使用场景">1.5 介绍Activity的几中启动模式，并简单说说自己的理解或者使用场景</h3><h2 id="2-_Service系列问题">2. Service系列问题</h2><h3 id="2-1_注册Service需要注意什么">2.1 注册Service需要注意什么</h3><p>Service还是运行在主线程当中的，所以如果需要执行一些复杂的逻辑操作，最好在服务的内部手动创建子线程进行处理，否则会出现UI线程被阻塞的问题</p>
<h3 id="2-2_Service与Activity怎么实现通信">2.2 Service与Activity怎么实现通信</h3><p>方法一：</p>
<ol>
<li>添加一个继承Binder的内部类，并添加相应的逻辑方法</li>
<li>重写Service的onBind方法，返回我们刚刚定义的那个内部类实例</li>
<li>Activity中创建一个ServiceConnection的匿名内部类，并且重写里面的onServiceConnected方法和onServiceDisconnected方法，这两个方法分别会在活动与服务成功绑定以及解除绑定的时候调用，在onServiceConnected方法中，我们可以得到一个刚才那个service的binder对象，通过对这个binder对象进行向下转型，得到我们那个自定义的Binder实例，有了这个实例，做可以调用这个实例里面的具体方法进行需要的操作了</li>
</ol>
<p>方法二<br>通过BroadCast(广播)的形式<br>   当我们的进度发生变化的时候我们发送一条广播，然后在Activity的注册广播接收器，接收到广播之后更新视图</p>
<h3 id="2-3_介绍源码中binder机制">2.3 介绍源码中binder机制</h3><h3 id="2-4_IntentService与Service的区别">2.4 IntentService与Service的区别</h3><blockquote>
<p>IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题</p>
</blockquote>
<ul>
<li>会创建独立的worker线程来处理所有的Intent请求；  </li>
<li>会创建独立的worker线程来处理onHandleIntent()方法实现的代码，无需处理多线程问题；  </li>
<li>所有请求处理完成后，IntentService会自动停止，无需调用stopSelf()方法停止Service；  </li>
<li>为Service的onBind()提供默认实现，返回null；  </li>
<li>为Service的onStartCommand提供默认实现，将请求Intent添加到队列中； </li>
<li>IntentService不会阻塞UI线程，而普通Serveice会导致ANR异常</li>
<li>Intentservice若未执行完成上一次的任务，将不会新开一个线程，是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用stopSelf()</li>
</ul>
<h2 id="3-_Handle系列问题">3. Handle系列问题</h2><h3 id="3-1_介绍Handle的机制">3.1 介绍Handle的机制</h3><ul>
<li>Handler通过调用sendmessage方法把消息放在消息队列MessageQueue中，Looper负责把消息从消息队列中取出来，重新再交给Handler进行处理，三者形成一个循环</li>
<li>通过构建一个消息队列，把所有的Message进行统一的管理，当Message不用了，并不作为垃圾回收，而是放入消息队列中，供下次handler创建消息时候使用，提高了消息对象的复用，减少系统垃圾回收的次数</li>
<li>每一个线程，都会单独对应的一个looper，这个looper通过ThreadLocal来创建，保证每个线程只创建一个looper，looper初始化后就会调用looper.loop创建一个MessageQueue，这个方法在UI线程初始化的时候就会完成，我们不需要手动创建</li>
</ul>
<h3 id="3-2_谈谈对HandlerThread的理解">3.2 谈谈对HandlerThread的理解</h3><h2 id="4-_ListView系列问题">4. ListView系列问题</h2><h3 id="4-1_ListView卡顿的原因与性能优化，越多越好">4.1 ListView卡顿的原因与性能优化，越多越好</h3><ol>
<li><p><strong>重用converView</strong>：<br>通过复用converview来减少不必要的view的创建，另外Infalte操作会把xml文件实例化成相应的View实例，属于IO操作，是耗时操作。</p>
</li>
<li><p><strong>减少findViewById()操作</strong>：<br>将xml文件中的元素封装成viewholder静态类，通过converview的setTag和getTag方法将view与相应的holder对象绑定在一起，避免不必要的findviewbyid操作</p>
</li>
<li><p><strong>避免在 getView 方法中做耗时的操作</strong>:<br>例如加载本地 Image 需要载入内存以及解析 Bitmap ，都是比较耗时的操作，如果用户快速滑动listview，会因为getview逻辑过于复杂耗时而造成滑动卡顿现象。用户滑动时候不要加载图片，待滑动完成再加载，可以使用这个第三方库<a href="https://github.com/bumptech/glide" target="_blank" rel="external">glide</a></p>
</li>
<li><p><strong>Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘</strong></p>
</li>
<li><p><strong>尽量能保证 Adapter 的 hasStableIds() 返回 true</strong><br>这样在 notifyDataSetChanged() 的时候，如果item内容并没有变化，ListView 将不会重新绘制这个 View，达到优化的目的</p>
</li>
<li><p><strong>在一些场景中，ScollView内会包含多个ListView，可以把listview的高度写死固定下来。</strong><br>由于ScollView在快速滑动过程中需要大量计算每一个listview的高度，阻塞了UI线程导致卡顿现象出现，如果我们每一个item的高度都是均匀的，可以通过计算把listview的高度确定下来，避免卡顿现象出现</p>
</li>
<li><p><strong>使用 RecycleView 代替listview</strong>：<br>每个item内容的变动，listview都需要去调用notifyDataSetChanged来更新全部的item，太浪费性能了。RecycleView可以实现当个item的局部刷新，并且引入了增加和删除的动态效果，在性能上和定制上都有很大的改善</p>
</li>
<li><p><strong>ListView 中元素避免半透明</strong>：<br>半透明绘制需要大量乘法计算，在滑动时不停重绘会造成大量的计算，在比较差的机子上会比较卡。 在设计上能不半透明就不不半透明。实在要弄就把在滑动的时候把半透明设置成不透明，滑动完再重新设置成半透明。</p>
</li>
<li><p><strong>尽量开启硬件加速</strong>：<br>硬件加速提升巨大，避免使用一些不支持的函数导致含泪关闭某个地方的硬件加速。当然这一条不只是对 ListView。</p>
</li>
</ol>
<h3 id="4-2_怎么实现一个部分更新的_ListView？">4.2 怎么实现一个部分更新的 ListView？</h3><h3 id="4-3_怎么实现ListView多种布局？">4.3 怎么实现ListView多种布局？</h3><h3 id="4-4_ListView与数据库绑定的实现">4.4 ListView与数据库绑定的实现</h3><h2 id="5-_JNI系列问题">5. JNI系列问题</h2><h3 id="5-1_如何使用JNI">5.1 如何使用JNI</h3><ol>
<li><p>JAVA中声明native 方法如private native String printJNI(String inputStr);</p>
</li>
<li><p>使用javah工具生成.h头文件这时候头文件中就会自动生成对应的函数JNIEXPORT jstring JNICALL Java_com_wenming_HelloWorld_printJNI </p>
</li>
<li><p>实现JNI原生函数源文件，新建HelloWorld.c文件，对刚才自动生成的函数进行具体的逻辑书写，例如返回一个java叫做HelloWorld的字符串等</p>
</li>
<li><p>编译生成动态链接so文件**</p>
</li>
<li><p>Java中调用Sysytem.load方法把刚才的so库加载进来，就可以调用native方法了</p>
</li>
</ol>
<h3 id="5-2_如何通过JNI传递String对象">5.2 如何通过JNI传递String对象</h3><p>Java的String和C++的string是不能对等起来的，所以当我们拿到.h文件下面的jstring对象，会做一次转换我们把jstring转换为C下面的char*类型，<br>获取值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constchar* str;</span><br><span class="line">str = env-&gt;GetStringUTFChars(prompt,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>赋予值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* tmpstr =<span class="string">"return string succeeded"</span>;</span><br><span class="line">jstring rtstr = env-&gt;NewStringUTF(tmpstr);</span><br></pre></td></tr></table></figure></p>
<h2 id="6-_OOM系列问题">6. OOM系列问题</h2><h3 id="6-1_什么OOM？">6.1 什么OOM？</h3><p>OOM全称是Out Of Merrory，Android系统的每一个应用程序都设置一个硬性的Dalvik Heap Size最大限制阈值，如果申请的内存资源超过这个限制，系统就会抛出OOM错误</p>
<h3 id="6-2_内存泄漏有哪些场景以及解决方法">6.2 内存泄漏有哪些场景以及解决方法</h3><ul>
<li><p><strong>类的静态变量持有大数据对象</strong><br>静态变量长期维持到大数据对象的引用，阻止垃圾回收。</p>
</li>
<li><p><strong>非静态内部类存在静态实例</strong><br>非静态内部类会维持一个到外部类实例的引用，如果非静态内部类的实例是静态的，就会间接长期维持着外部类的引用，阻止被回收掉。</p>
</li>
<li><p><strong>资源对象未关闭</strong><br>资源性对象比如（Cursor，File文件等）往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们， 以便它们的缓冲及时回收内存。它们的缓冲不仅存在于java虚拟机内，还存在于java虚拟机外。 如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄露。<br><strong>解决办法</strong>： 比如SQLiteCursor（在析构函数finalize（）,如果我们没有关闭它，它自己会调close()关闭）， 如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。 因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null. 在我们的程序退出时一定要确保我们的资源性对象已经关闭。       程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小， 对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险，记得try catch后，在finally方法中关闭连接</p>
</li>
<li><p><strong>Handler内存泄漏</strong><br>Handler作为内部类存在于Activity中，但是Handler生命周期与Activity生命周期往往并不是相同的，比如当Handler对象有Message在排队，则无法释放，进而导致本该释放的Acitivity也没有办法进行回收。<br><strong>解决办法</strong>：</p>
</li>
</ul>
<ol>
<li>声明handler为static类，这样内部类就不再持有外部类的引用了，就不会阻塞Activity的释放</li>
<li><p>如果内部类实在需要用到外部类的对象，可在其内部声明一个弱引用引用外部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CustomHandler mHandler;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mHandler = <span class="keyword">new</span> CustomHandler(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomHandlerextends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 内部声明一个弱引用，引用外部类</span></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;MainActivity &gt; activityWeakReference;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MyActivity activity)</span> </span>&#123;</span><br><span class="line">            activityWeakReference= <span class="keyword">new</span> WeakReference&lt;MainActivity &gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// ... ...   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Activity onStop或者onDestroy的时候，取消掉该Handler对象的Message和Runnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  If null, all callbacks and messages will be removed.</span></span><br><span class="line">    mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><strong>一些不良代码习惯</strong><br>有些代码并不造成内存泄露，但是他们的资源没有得到重用，频繁的申请内存和销毁内存，消耗CPU资源的同时，也引起内存抖动<br><strong>解决方案</strong><br>如果需要频繁的申请内存对象和和释放对象，可以考虑使用对象池来增加对象的复用。 例如ListView便是采用这种思想，通过复用converview来避免频繁的GC</li>
</ul>
<h3 id="6-2_如何避免_OOM_问题的出现">6.2 如何避免 OOM 问题的出现</h3><p><strong>1. 使用更加轻量的数据结构</strong><br>例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效，在于他们避免了对key与value的自动装箱（autoboxing），并且避免了装箱后的解箱。</p>
<p><strong>2. 避免在Android里面使用Enum</strong><br>Android官方培训课程提到过“Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.”，具体原理请参考《Android性能优化典范（三）》，所以请避免在Android里面使用到枚举。</p>
<p><strong>3. 减小Bitmap对象的内存占用</strong><br>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用可谓是重中之重，，通常来说有以下2个措施：<br><strong>inSampleSize</strong>：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。<br><strong>decode format</strong>：解码格式，选择ARGB_6666/RBG_545/ARGB_4444/ALPHA_6，存在很大差异</p>
<p><strong>4.Bitmap对象的复用</strong><br>缩小Bitmap的同时，也需要提高BitMap对象的复用率，避免频繁创建BitMap对象，复用的方法有以下2个措施<br><strong>LRUCache</strong> : “最近最少使用算法”在Android中有极其普遍的应用。ListView与GridView等显示大量图片的控件里，就是使用LRU的机制来缓存处理好的Bitmap，把近期最少使用的数据从缓存中移除，保留使用最频繁的数据，<br><strong>inBitMap高级特性</strong>:利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小</p>
<p><strong>4. 使用更小的图片</strong><br>在涉及给到资源图片时，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用更小的图片。尽量使用更小的图片不仅可以减少内存的使用，还能避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图时会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</p>
<p><strong>5.StringBuilder</strong><br>在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</p>
<p><strong>4.避免在onDraw方法里面执行对象的创建</strong><br>类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p>
<p><strong>5. 避免对象的内存泄露</strong><br>android中内存泄漏的场景以及解决办法，参考上一问</p>
<h2 id="7-_ANR_系列问题">7.  ANR 系列问题</h2><h3 id="7-1_什么ANR">7.1 什么ANR</h3><p>ANR全称Application Not Responding，意思就是程序未响应。如果一个应用无法响应用户的输入，系统就会弹出一个ANR对话框，用户可以自行选择继续等待亦或者是停止当前程序。一旦出现下面两种情况，则弹出ANR对话框</p>
<ul>
<li><strong>应用在5秒内未响应用户的输入事件（如按键或者触摸）</strong></li>
<li><strong>BroadcastReceiver未在10秒内完成相关的处理</strong></li>
</ul>
<h3 id="7-2_ANR是怎么引起的？">7.2 ANR是怎么引起的？</h3><ul>
<li><strong>主线程中存在耗时的计算-</strong></li>
<li><strong>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。-</strong></li>
<li><strong>主线程中错误的操作，比如Thread.wait或者Thread.sleep等</strong></li>
</ul>
<h3 id="7-3_如何避免ANR问题的出现">7.3 如何避免ANR问题的出现</h3><p>基本思路就是把一些耗时操作放到子线程中处理</p>
<ul>
<li><p><strong>使用AsyncTask处理耗时IO操作。</strong></p>
</li>
<li><p><strong>降低子线程优先级使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</strong></p>
</li>
<li><p><strong>使用Handler处理子线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</strong></p>
</li>
<li><p><strong>Activity的onCreate和onResume回调中尽量避免耗时的代码</strong></p>
</li>
<li><p><strong>BroadcastReceiver中onReceive代码也要尽量减少耗时操作建议使用IntentService处理。IntentService是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题</strong></p>
</li>
</ul>
<h2 id="8-_Asynctask问题">8. Asynctask问题</h2><h3 id="8-1_AsynTask为什么要设计为只能够一次任务？">8.1 AsynTask为什么要设计为只能够一次任务？</h3><p>最核心的还是线程安全问题，多个子线程同时运行，会产生状态不一致的问题。所以要务必保证只能够执行一次</p>
<h3 id="8-2_AsynTask造成的内存泄露的问题怎么解决，》比如非静态内部类AsynTask会隐式地持有外部类的引用，如果其生命周期大于外部activity的生命周期，就会出现内存泄漏">8.2 AsynTask造成的内存泄露的问题怎么解决，》比如非静态内部类AsynTask会隐式地持有外部类的引用，如果其生命周期大于外部activity的生命周期，就会出现内存泄漏</h3><ul>
<li>注意要复写AsynTask的onCancel方法，把里面的socket，file等，该关掉的要及时关掉</li>
<li>在 Activity 的onDestory()方法中调用Asyntask.cancal方法</li>
<li>Asyntask内部使用弱引用的方式来持有Activity</li>
</ul>
<h3 id="8-3_若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗?">8.3 若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗?</h3><p>当一个App旋转时，整个Activity会被销毁和重建。当Activity重启时，AsyncTask中对该Activity的引用是无效的，因此onPostExecute()就不会起作用，若AsynTask正在执行，折会报 view not attached to window manager 异常</p>
<p>同样也是生命周期的问题，在 Activity 的onDestory()方法中调用Asyntask.cancal方法，让二者的生命周期同步</p>
<h3 id="8-4_Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？">8.4 Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？</h3><p>还是屏幕旋转这个例子，在重建Activity的时候，会回掉Activity.onRetainNonConfigurationInstance()重新传递一个新的对象给AsyncTask，完成引用的更新</p>
<h2 id="9-_Android触摸分发机制">9. Android触摸分发机制</h2><h3 id="9-1_介绍触摸事件的分发机制">9.1 介绍触摸事件的分发机制</h3><p><img src="https://farm8.staticflickr.com/7062/14110505861_6569e33985_o.jpg" alt="enter image description here"></p>
<p>(1) 事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。</p>
<p>(2) 事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。</p>
<p>(3) 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。</p>
<p>(4) 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。</p>
<p>(5) OnTouchListener优先于onTouchEvent()对事件进行消费。</p>
<p>上面的消费即表示相应函数返回值为true。</p>
<h3 id="9-2_View中_setOnTouchListener的onTouch，onTouchEvent，onClick的执行顺序">9.2 View中 setOnTouchListener的onTouch，onTouchEvent，onClick的执行顺序</h3><p>追溯到View的dispatchTouchEvent源码查看，有这么一段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (!onFilterTouchEventForSecurity(event)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  </span><br><span class="line">                mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(event);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>当以下三个条件任意一个不成立时，</p>
<ul>
<li>mOnTouchListener不为null</li>
<li>view是enable的状态</li>
<li>mOnTouchListener.onTouch(this, event)返回true，</li>
</ul>
<p>函数会执行到onTouchEvent。在这里我们可以看到，首先执行的是mOnTouchListener.onTouch的方法，然后是onTouchEvent方法</p>
<p>继续追溯源码，到onTouchEvent()观察，发现在处理ACTION_UP事件里有这么一段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!post(mPerformClick)) &#123;  </span><br><span class="line">                                   performClick();  </span><br><span class="line">                               &#125;</span><br></pre></td></tr></table></figure></p>
<p>此时可知，onClick方法也在最后得到了执行</p>
<p>所以三者的顺序是：</p>
<ol>
<li>setOnTouchListener() 的onTouch</li>
<li>onTouchEvent()</li>
<li>onClick()</li>
</ol>
<h2 id="10-_Dalvik虚拟机系列问题">10. Dalvik虚拟机系列问题</h2><h3 id="10-1_什么是Dalvik虚拟机？">10.1 什么是Dalvik虚拟机？</h3><p> Dalvik虚拟机是Android平台的核心。它可以支持.dex格式的程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，可以减少整体文件尺寸，提高I/O操作的速度，适合内存和处理器速度有限的系统。</p>
<h3 id="10-2_Dalvik虚拟机的作用是什么？">10.2 Dalvik虚拟机的作用是什么？</h3><p>Dalvik虚拟机主要是完成对象生命周期管理，内存回收，堆栈管理，线程管理，安全和异常管理等等重要功能。</p>
<h3 id="10-3_Dalvik虚拟机与JVM有什么区别">10.3 Dalvik虚拟机与JVM有什么区别</h3><ul>
<li>Dalvik 基于寄存器，而 JVM 基于栈。基于寄存器的虚拟机对于更大的程序来说，在它们编译的时候，花费的时间更短。</li>
<li>Dalvik执行.dex格式的字节码，而JVM执行.class格式的字节码。</li>
</ul>
<h3 id="10-4_每个应用程序对应多少个Dalvik虚拟机">10.4 每个应用程序对应多少个Dalvik虚拟机</h3><ul>
<li>每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行 ，而所有的Android应用的线程都对应一个Linux线程</li>
</ul>
<h2 id="11-_注册广播接收器有哪几种方式,有什么区别">11. 注册广播接收器有哪几种方式,有什么区别</h2><ul>
<li>静态注册：在AndroidManifest.xml文件中进行注册，当App退出后，Receiver仍然可以接收到广播并且进行相应的处理</li>
<li>动态注册：在代码中动态注册，当App退出后，也就没办法再接受广播了</li>
</ul>
<h2 id="12-_显示Intent与隐式Intent的区别">12. 显示Intent与隐式Intent的区别</h2><p>对明确指出了目标组件名称的Intent，我们称之为“显式Intent”。<br>对于没有明确指出目标组件名称的Intent，则称之为“隐式 Intent”。</p>
<p>对于隐式意图，在定义Activity时，指定一个intent-filter，当一个隐式意图对象被一个意图过滤器进行匹配时，将有三个方面会被参考到：</p>
<ul>
<li>动作(Action)</li>
<li>类别(Category [‘kætɪg(ə)rɪ] )</li>
<li>数据(Data )</li>
</ul>
<h2 id="13-_Android中的动画有哪些，区别是什么">13. Android中的动画有哪些，区别是什么</h2><ul>
<li><p><strong>逐帧动画(Drawable Animation)</strong>：<br>加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间</p>
</li>
<li><p><strong>补间动画(Tween Animation)</strong>：<br>Tween可以对View对象实现一系列简单的动画效果，比如位移，缩放，旋转，透明度等等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。</p>
</li>
<li><p><strong>属性动画(Property Animation)</strong>：<br>动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了</p>
</li>
</ul>
<h2 id="14-_不使用动画，怎么实现一个动态的_View？">14. 不使用动画，怎么实现一个动态的 View？</h2><h2 id="15-_Postvalidata与Validata有什么区别？">15. Postvalidata与Validata有什么区别？</h2><h2 id="16-_如何自定义ViewGroup？">16. 如何自定义ViewGroup？</h2><h2 id="17-_View的绘制流程">17. View的绘制流程</h2><p><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tech/viewdrawflow/image/view_mechanism_flow.png" alt="enter image description here"><br>measure()方法，layout()，draw()三个方法主要存放了一些标识符，来判断每个View是否需要再重新测量，布局或者绘制，主要的绘制过程还是在onMeasure，onLayout，onDraw这个三个方法中</p>
<p><strong>1.onMesarue() </strong><br>为整个View树计算实际的大小，即设置实际的高(对应属性:mMeasuredHeight)和宽(对应属性:<br>  mMeasureWidth)，每个View的控件的实际宽高都是由父视图和本身视图决定的。</p>
<p><strong>2.onLayout()</strong><br>为将整个根据子视图的大小以及布局参数将View树放到合适的位置上。</p>
<p><strong>3. onDraw() </strong><br>开始绘制图像，绘制的流程如下</p>
<ol>
<li>首先绘制该View的背景</li>
<li>调用onDraw()方法绘制视图本身  (每个View都需要重载该方法，ViewGroup不需要实现该方法)</li>
<li>如果该View是ViewGroup，调用dispatchDraw ()方法绘制子视图</li>
<li>绘制滚动条</li>
</ol>
<h2 id="18-_数据持久化的四种方式有哪些？">18. 数据持久化的四种方式有哪些？</h2><ol>
<li><p><strong>文件存储</strong>：<br>通过java.io.FileInputStream和java.io.FileOutputStream这两个类来实现对文件的读写，java.io.File类则用来构造一个具体指向某个文件或者文件夹的对象。</p>
</li>
<li><p><strong>SharedPreferences</strong>：<br>SharedPreferences是一种轻量级的数据存储机制，他将一些简单的数据类型的数据，包括boolean类型，int类型，float类型，long类型以及String类型的数据，以键值对的形式存储在应用程序的私有Preferences目录（/data/data/&lt;包名&gt;/shared_prefs/）中，这种Preferences机制广泛应用于存储应用程序中的配置信息。</p>
</li>
<li><p><strong>SQLite数据库</strong>：<br>当应用程序需要处理的数据量比较大时，为了更加合理地存储、管理、查询数据，我们往往使用关系数据库来存储数据。Android系统的很多用户数据，如联系人信息，通话记录，短信息等，都是存储在SQLite数据库当中的，所以利用操作SQLite数据库的API可以同样方便的访问和修改这些数据。</p>
</li>
<li><p><strong>ContentProvider</strong>:<br>主要用于在不同的应用程序之间实现数据共享的功能，不同于sharepreference和文件存储中的两种全局可读写操作模式，内容提供其可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏的风险</p>
</li>
</ol>
<h2 id="19-_fragement里面可以再嵌套fragment？">19. fragement里面可以再嵌套fragment？</h2><h2 id="20-_Socker编程的步骤">20. Socker编程的步骤</h2><h2 id="21-_Activity中如何动态的添加Fragment">21. Activity中如何动态的添加Fragment</h2><h2 id="22-_Scrollview怎么判断是否滑倒底部">22. Scrollview怎么判断是否滑倒底部</h2><h2 id="23-_什么是_MVC_模式？MVC_模式的好处是什么？">23. 什么是 MVC 模式？MVC 模式的好处是什么？</h2><h2 id="24-_应用常驻后台，避免被第三方杀掉的方法，讲讲你用过的奇淫巧技？">24. 应用常驻后台，避免被第三方杀掉的方法，讲讲你用过的奇淫巧技？</h2><ol>
<li><p><strong>Service设置成START_STICKY</strong><br>kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样</p>
</li>
<li><p><strong>通过 startForeground将进程设置为前台进程</strong>，<br>做前台服务，优先级和前台应用一个级别​，除非在系统内存非常缺，否则此进程不会被 kill</p>
</li>
<li><p><strong>双进程Service</strong>：<br>让2个进程互相保护**，其中一个Service被清理后，另外没被清理的进程可以立即重启进程</p>
</li>
<li><p><strong>QQ黑科技</strong>:<br>在应用退到后台后，另起一个只有 1 像素的页面停留在桌面上，让自己保持前台状态，保护自己不被后台清理工具杀死</p>
</li>
<li><p><strong>在已经root的设备下，修改相应的权限文件,将App伪装成系统级的应用</strong><br>Android4.0系列的一个漏洞，已经确认可行</p>
</li>
</ol>
<ol>
<li><strong>用C编写守护进程(即子进程) </strong>:<br>Android系统中当前进程(Process)fork出来的子进程，被系统认为是两个不同的进程。当父进程被杀死的时候，子进程仍然可以存活，并不受影响。<strong>鉴于目前提到的在Android-&gt;- Service层做双守护都会失败</strong>，我们可以fork出c进程，多进程守护。死循环在那检查是否还存在，具体的思路如下（Android5.0以上的版本不可行）</li>
</ol>
<ul>
<li>用C编写守护进程(即子进程)，守护进程做的事情就是循环检查目标进程是否存在，不存在则启动它。</li>
<li>在NDK环境中将1中编写的C代码编译打包成可执行文件(BUILD_EXECUTABLE)。主进程启动时将守护进程放入私有目录下，赋予可执行权限，启动它即可。</li>
</ul>
<ol>
<li><strong>联系厂商，加入白名单</strong></li>
</ol>
<h2 id="25-Context与ApplicationContext的区别，分别用在什么情况下">25.Context与ApplicationContext的区别，分别用在什么情况下</h2><p>Application的Context是一个全局静态变量，SDK的说明是只有当你引用这个context的生命周期超过了当前activity的生命周期，而和整个应用的生命周期挂钩时，才去使用这个application的context。</p>
<p>在android中context可以作很多操作，但是最主要的功能是加载和访问资源。在android中有两种context，一种是 application context，一种是activity context，通常我们在各种类和方法间传递的是activity context。</p>
<h2 id="26-_同一个应用程序的不同Activity可以运行在不同的进程中么？如果可以，举例说明；">26. 同一个应用程序的不同Activity可以运行在不同的进程中么？如果可以，举例说明；</h2><h2 id="27-_Java中的线程同步有哪几种方式，举例说明；">27. Java中的线程同步有哪几种方式，举例说明；</h2><h2 id="28-_dp,_dip,_dpi,_px,_sp是什么意思以及他们的换算公式？layout-sw400dp,_layout-h400dp分别代表什么意思；">28. dp, dip, dpi, px, sp是什么意思以及他们的换算公式？layout-sw400dp, layout-h400dp分别代表什么意思；</h2><h2 id="29-_如何让两个TextView在一个RelativeLayout水平居中显示；">29. 如何让两个TextView在一个RelativeLayout水平居中显示；</h2><h2 id="30-_如何画出一个印章的图案">30. 如何画出一个印章的图案</h2><h2 id="31-_如何实现一个字体的描边与阴影效果">31. 如何实现一个字体的描边与阴影效果</h2><h2 id="32-_设计一个从网络请求数据，图片，并加载到列表的系统，画出客户端架构并简单的分析下；">32. 设计一个从网络请求数据，图片，并加载到列表的系统，画出客户端架构并简单的分析下；</h2><h2 id="33-_设计一个文件的断点续传系统；">33.  设计一个文件的断点续传系统；</h2><h2 id="34-_设计一个图片缓存加载机制">34. 设计一个图片缓存加载机制</h2>
</article>
<div id="post__share">
    <!-- 打赏入口 -->
    <a id="icon-heart" class="fontello" href="#"></a>
</div>

    <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more">分享到：</a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间">QQ空间</a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博">新浪微博</a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博">腾讯微博</a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信">微信</a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网">豆瓣网</a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记">有道云笔记</a><a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记">印象笔记</a></div>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","renren","tqq","bdxc","kaixin001","tqf","tieba","douban","bdhome","sqq","thx","ibaidu","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","mail","isohu","wealink","ty","fbook","twi","linkedin","h163","evernotecn","print"],"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{"bdSize":16},"image":{"viewList":["qzone","tsina","tqq","weixin","douban","youdao","evernotecn"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>



      
      </div>
      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">目录</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div>
    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>
<script src="/js/js-lib.js" type="text/javascript"></script>
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?a01595b492af7e4a793230e3d49ae638";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
  </body>
</html>